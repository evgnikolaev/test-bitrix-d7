<? /*

 https://academy.1c-bitrix.ru/education/index.php?COURSE_ID=91&INDEX=Y

D7. Разработка собственного модуля


2) Модуль - модель данных. api для доступа.
	Стандартные - можно удалить и восстановить.
	Маркетплейс - пользовательские. (Маркетплейс-установленные решения)можно удалить и восстановить. !!!!! Если нажать СТЕРЕТЬ то полностью снесем !!!!!

	Модуль может установиться и в bitrix и в local. Поэтому жестко путь не нужно зашивать!!!!!

	Из маркетплейс устанавливается в bitrix/modules/.
	Скачивание из маркетплейс перезатрет модуль если он уже был установлен в папке bitrix.

	По приоритету модуль берется из папки local.


3) структура модуля

	id модуля - это название папки модуля. Состоит из 2-х частей: 	имя партнера.идентификатор модуля    ( Например: academy.d7 )
	Обязательно разделяем точкой, чтобы битрикс не подумал что это системный модуль.

	имя партнера - предназначена для маркетплейса,
				для локальной разработки все равно используем (может быть логин, имя латиницей), для избежания совпадения id модуля.

	идентификатор модуля - наименование модуля. не нужно использовать длинные названия.


	 Требования
		- латинские буквы и цифры (цифра не в первой позиции)
		- нижний регистр
		- нельзя использовать подчеркивания



	Структура:

	lib 	- основные классы модуля. (необязательно)

	install - основная папка. установка и удаления.
			admin 			-  испольняемые файлы админки, которые при установки перемещаются в bitrix/admin.
								!! не должны содержать кода для админки модуля. только подключение.Сам код в папке admin в корне модуля.
			index.php 		- основной файл, код установки и удаления
			version.php  	- версия модуля
			step.php 		- пошаговая установка, необязательно
			db 				- можно разместить sql файлы, которые будут выполнятся при установке модуля. Размещаем в подпапке с именем базы.
			components 		- компоненты модуля

	admin 	- испольняемые файлы админки (своя админка)
		menu.php					 - файл административного меню модуля
		operation_description.php 	 - файл с описанием операция для расширенного управления правами доступа
		task_description.php 		 - файл с описанием уровней доступа для расширенного управления правами доступа

	lang 	-  языковые файлы (повторяют структуру модуля)

	include.php - обязательный, в старом ядре был важным файлом(в ней подключались все классы модуля)
					Подключается при инициализации модуля при выполнении скриптов сайта.
					Можно использовать например для принуительного подключения классов, или когда нужно выполнить какой-то код при инициализации модуля

	options.php - страница настроек модуля.

	Также старые файлы и папки используются для совместимости.



4-5) установка и удаление папка install
	Описываем установку модуля, удаление модуля, описываем основные параметры модуля


6)   взаимодействия модулей. 2 способа:
	- Использование API стороннего модуля. сперва его нужно подключить.
	- События
	!!! Работа с событиями на уровне модуля не предусматривает использования init.php !!!!
	111 Регистрация обработчика должна производится один раз при установке, при удалении модуля эту регистрацию нужно снимать !!!
	!!! Если не опишем события, то при взаимодействии модулей не сможем настроить это взаимодействие !!!
	Дополнительно 17 урок.

7) settings.php - конфигурационный файл битрикса.
	Также можно использовать для хранения своих настроек,	используя - \Bitrix\Main\Config\Configuration


9) исключения
		Используется целая иерархия исключений от класса php исключений\Exception.
		Можно создать свои унаследовавшись от любого класса иерархии.

		divisionerror.php   - собственный класс исключений
		division.php        - \Academy\D7\Division::divided(4, 0); - при вызове выбросится исключение
								не обязателен, даже конструкцией throw new \Academy\D7\DivisionError('Деление на ноль', 4, 0); выбросится исключение)


				Работа исключений

				namespace DivisionError;
				use Throwable;

				class DivisionError extends \Exception{
					public function __construct($type = 'division zero', $parameter1 = 0, $parameter2 = 0, \Exception $previous = null)
					{
						$message = 'An error has occured: ' . $type;
						parent::__construct($message);
					}
				}

				try {
					if (1) {
						throw new \Exception('Деление на ноль.');
						throw new DivisionError('Деление на ноль.');
					}
				} catch (Throwable $e) {
					echo 'Выброшено исключение: ',  $e->getMessage(), "\n";
				}


10) Настройка модулей

	options.php - здесь настройки, вкладки.
	Также при удалении модуля нужно удалять настройки модуля



11) права доступа
	Права - если пользователь обладает несколькими правами , то выбирается максимальное
	Роли - если пользователь обладает несколькими ролями, то он будет обладать суммарной возможностью этих ролей (не рассматриваем)

	Описываем в install/index.php метод GetModuleRightList (Определяем собственные права, если не описать этот метод, будут стандартные права(закрыт, просмотр, запись))

    в options.php добавляем возможность для вкладки менять права конструкцией
	 require_once($_SERVER["DOCUMENT_ROOT"] . "/bitrix/modules/main/admin/group_rights.php");

	Проверяем доступ в option.php , или в компоненте, если нужно конструкцией
	$APPLICATION->GetGroupRight($module_id)



----------------------- ORM  ---------------------


 12) 3 варианта зранения данных:

		    Инфоблоки           - требуется быстро развернуть и настроить структуру данных
		                        требуется админка, понятная любому контент-менеджеру
		                        требуется весь богатый функионал инфоблоков.

		    Highload - блоки    - большой объем данных, большая загрузка
		                        Хранение служебных данных, которая не будет редактироваться контент менеджером
		                        Упрощенная админка, в отличие от инфоблоков.
		                        Нет возможности организовать каталог с каталогизатором

		    ORM                 - очень сложная структура данных,
		                        очень высоки нагрузки и объем данных
		                        Это самая быстрая структура хранения данных
		                        При этом нужно организовать свою админку для доступа к данным
		                         Инексацию поиска, все придется писать самому



 13)  Создание ORM-сущности
		    Сущность - совокупность коллекций объектов с присущей им базовой (низкоуровневой) бизнес логикой.
		    Сущность обладает набором характеристик, значения которых подчиняются определенным правилам обработки.
		    Одна сущность описывает одну таблицу в БД, и связь с другими ORM-сущностями.
		    book.php - пример


 14) Создание и удаление

            При установке, удалении модуля можно просто написать sql запрос на добавление и удаление таблиц.
            Это неправильный подход, у нас в нескольких местах будет описана структура таблиц.
			Нужно использовать методы ORM  и методы битрикс для работы с БД  на низком уровне(в том числе методы DDL)


 15)  Обновление, удаление, изменение - test.php
        !!!  Обновление, удаление, изменение для нескольких элементов нужно делать в цикле  !!!


 16) Использование валидаторов

	Валидаторы - проверка данных перед добавлением в БД.
	Валидаторы - callback, который возвращает массив валидаторов (не массив валидаторов).
                Это своего рода отложенная загрузка. Валидаторы будут инициализированы только тогда, когда действительно нужна будет валидация данных.
                В большинстве же случаях, например при выборке данных, валидация не нужна.

    В качестве валидатора применяется наследник Entity\Validator\Base или любой callback.
    Указанный callback должен вернуть true, или текст ошибки, или объект Emtity\FieldError когда мы хотим использовать собственный код ошибки.


        Штатные валидаторы (наследники  Entity\Validator\Base ) :
			 Bitrix\Main\Entity\Validator\RegExp - проверка по регулярному выражению
			 Bitrix\Main\Entity\Validator\Length - проверка на максимальную, мимнимальную длину
			 Bitrix\Main\Entity\Validator\Range - проверка на максимальное, мимнимальное знаение числа
			 Bitrix\Main\Entity\Validator\Unique - проверка на уникальность



   17) Автоматически создаваемые события у ORM-сущности

		    9 событий (по 3 на Add, Update, Delete - <ACTION>)

		        до          onBefore<ACTION>       - можно ищменить данные, можно сгенерировать ошибку.
							<вызов валидаторов>      - прерываение операции в случае наличия ошибок
				в момент    on<Action>             - можно сгенерировать ошибку (нельзя изменить входящие данные), выполняется до фактического выполнения sql запроса
							выполнение SQL запроса
				после       onAfter<Action>         - здесь можем узнать о выполнениии операции, отменить операцию, внести изменения уже не можем


				1) способ, в init.php
		        2) способ, событие из другого модуля (описывается при установке модуля)

		        Если нам нужно в одном модуле использовать событие другого модуля
				Допустим создали другой модуль academy.event.  В его папке install/index.php

				\Bitrix\Main\EventManager::getInstance()->registerEventHandler(
		                academy.d7,                          - id модуля, к которому отностится событие
		                '\Academy\D7\Book::OnBeforeAdd',     - id события, обработчик которого мы буде мрегистрировать
		                 $this->MODULE_ID,                   - id модуля, к которому относится регистрируемый обраотчик
		                 '\Academy\D7\Event',                - Класс где лежит обработчик
		                  'eventHandler'                     - метод, сам обработчик
		         );

				3) Обработчик сразу при описании ORM-сущности (подключается автоматически)
						Стандартные методы формируются автоматически при описании ORM-сущности, и нет доступа к ним. Но зачастую нужно изменить их поведение.
		                Например нужно изменить какие-то данные перед сохранением, права доступа и т.д.



      18) Использование вычисляемых значений.
			Периодически разработчики сталкиваются с реализацией счетчиков, где для целостности данных предпочтительно рассчитывать знаение на стороне БД,
            вместо выборки старого значения и пересчете его на стороне приложения.
            Например таким образом реализуются счетчики количества просмотра какого-то элемента.
			Для этого в ORM есть вычисляемые значения.

			!!!! Если создается новое поле в getMap,
                    мы либо вручную должны создать колонку в таблице БД,
                     либо удалить модуль с удалением данных из БД и установить модуль повторно, При этом будет повторно создана таблица по ORM-структуре.
            !!!  Если этого не сделать, то при обращении к новому полю , который есть в getMap, но нет в таблице, мы получим ошибку

			 $result = BookTable::update(1, [
				'NAME' => 'книга изменненная',
				'WRITE_COUNT'=> new Bitrix\Main\DB\SqlExpression('?# + 1','WRITE_COUNT') - конструктор с плейсхолдером
                                                         ? или ?s - Значение экранируются и заключаются в кавычки '
														 ?# - значение экранируется как идентификатор
														 ?i - значение приводится к integer
														 ?f - значение приводится к float
			]);

			Вычисляемые значения - используются когда берем значение, неважно какое оно, произвести с ним действия и положить обратно.


        19) getlist
				Если раньше имел разные параметры, то сейчас единый.
                Пример test.php


		20) Использование секции runtime в getlist

		      1)  У getlist есть еще параметр  runtime  - Динамически созданное поле ExpressionField - чаще.
		                 ExpressionField поля чаще нужны не в описании сущности (getMap), сколько при различных выборках с группировкой.
		                 Например один из вариантов применения - подсчет количества элементов (его не нужно описывать в описании сущности getMap)

		     2)  Использование runtime для добавления  полей других типов.
		            В runtime можно регистрировать не только EspressionFields, но и поля любых других типов
		            !!  Механизм runtime работает таким образом, что к сущности добавляется новое поле, будто оно было описано в ней изначально в методе getMap !!
			                 Пример:
			                 Мы в таблице БД добавили новое поле ACTIVITY, но не описали ее в getMap.
			                 в runtime объявим это поле при помощи new \Bitrix\Main\Entity\IntegerField('ACTIVITY'),
		            Особенностью поля runtime является то что он виден только в рамках одного запроса. При следующем вызове такое поле уже будет недоступно.
		            Придется заново его зарегистрировать. Поэтому причины использования такого поля могут быть:
		            - Вы используете ORM-сущность созданную не вами, и править его не можете. А с помощъю runtime вы дополняете ORM-сущность.
		            - Ваше поле будет использоваться только в одном запросе, и смысла в рамках других не имеет.
					- Описанное поле не имеет смысла описывать в описании сущности (EspressionFields).

		21) Использование коротких вызовов
		                Обертки над getlist:
		        getById( $id )                              - выборка по первичному ключу, вернет DbResult.Возвращаются все поля кроме динамических связей.
		        getByPrimary( $primary , array $parameters) - выборка по первичному ключу с возможностью указания параметров(например фильтр или селект).
		                                                        можно в выборку добавить динамические поля и поля связанных элементов.
			        Оба метода можно передать $id в виде числа, или массив('имя поля первичного ключа'=> 'значение').
			        Это не фильтр, сложную логику здесь применять нельзя.
		        getRowById( $id )                           - выборка по первичному ключу. Аналог getById, но возвращает сразу массив данных.
		        getRow( array $parameters )                 - аналог getlist, возвращает только первый элемент  возвращает сразу массив данных.


		22) Использование query
	            getlist тоже является оберткой.
	            На самом деле есть вариант объектного подхода получения данных в ORM.
	            То есть когда вы получаете экземпляр класса и ис помощью спуциальных методов задаете нужные параметры (выбираемые поля, фильтр, группировку).
	            А когда все готово, с помощью специального метода выполняем запрос.
                Этот вариант дает большую гибкость, Например если параметры запроса заранее неизвестны и формируются программно(накапливая запросы, а также изменяя их).
				test.php
				!! удобно использовать, когда парметры собираются в разных местах, когда идет большая подготовительная работа перед запросом !!!
                !! Все методы - https://take.ms/9KlpA !!


        23)	Для связывания ORM-сущностей между собой используется 3 вида связи:
                test_11_1N_MN.php

				1:1 - элемент ссылается на один элемент другой или этой же сущности (связь одна книга - один автор). Также можно создавать цепочки связей.
						 book1N.php
						 author1N.php


				1:N - один ко многим или обратный reference.
                        Концепция ReferenceField подразумевает, что это поле нужно размещать в сущности N, отношения 1:N.
                        То еть reference должен указывать строго на одну запись.	Ранее в примере было показано что у книги может быть только один автор.
						Таким образом ReferenceField сущности книги указывает на одну запись сущности автора.
                        Как выбрать поля автора книги понятно, так как в сущности книги указаны связи с сущностью автора.
                        Но как выбрать все книги автора, если в сущности автора нет указаний на книги?
                        !!!  Описанный reference в сущности книги уже достаточен для двусторонней выборки   !!!
                        Используем только специальный синтаксис в гетлист, описание ORM-сущности мы не меняем.
                            book1N.php
						    author1N.php


			    M:N - сущность связана сразу с несколькими элементами другой сущности. И вторая сущности привязана к нескольким элементам первой.
                        Одна книга иммет много авторов, а один автор в соавторстве может написать много книг.
                        Такой вариант можно реализовать используя промежуточную таблицу.
                            book2.php
                            bookauthorsus.php - промежуточная таблица
						    author.php
						Связи опишем в промежуточной таблице, для книг и авторов дополнительных связей не создаем.
                        Используя специальный синтаксис в гетлисте получаем данные.








        24) Некоторые полезные классы d7.
                не все методы были переписаны на новое ядро. Поэтому пока используем и старые и новые классы.

            \Bitrix\Main\IO - для работы с файлами и папками.
				\Bitrix\Main\IO\Path - для работы с путями (имеет целый набор статических методов)
				\Bitrix\Main\IO\Directory - для работы с папками (копирование, перемещение, удаление)
				\Bitrix\Main\IO\File - для работы с файлами


             \Bitrix\Main\Web\HttpClient - для работы с Http, содержит методы, которые выполнфют запросы на удаленные сервера.
                                            Содержит только динамические методы(то есьб нужно создавать объект)
			  $http = new \Bitrix\Main\Web\HttpClient(array $options=null);
              $http->get($url)                              get-запрос
              $http->post($url,$postData)                   post-запрос
              $http->setCookie($cookie)                     Установить при запросе куки
              $http->setAuthorization($user, $password)     http-авторизация при запросе
              $http->setAuthorization($user, $password)     http-авторизация при запросе
              $http->download($url, $path)                  Загрузить файл с удаленного сервера


			Для работы с датой, временем:
            \Bitrix\Main\Type\Date
            \Bitrix\Main\Type\DateTime


            Для работы с Url (разбирает урл):
            \Bitrix\Main\Web\Uri


*/ ?>

